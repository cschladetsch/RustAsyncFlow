#!/usr/bin/env python3
"""
AsyncFlow Python Demo - Cross-platform demonstration
Works on Windows, macOS, and Linux with Python 3.7+

Usage:
  python pyr      (Windows/cross-platform)
  python3 pyr     (Linux/macOS)  
  ./pyr           (Unix with executable permissions)
"""

import asyncio
import sys
import os
import platform

# Add python_asyncflow to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'python_asyncflow'))

try:
    from python_asyncflow import AsyncKernel, FlowFactory
except ImportError as e:
    print("‚ùå Error importing AsyncFlow components")
    print(f"Error: {e}")
    print("Make sure all python_asyncflow files are present")
    sys.exit(1)


def check_python_version():
    """Check if Python version is compatible"""
    version = sys.version_info
    if version.major < 3 or (version.major == 3 and version.minor < 7):
        print(f"‚ùå Python {version.major}.{version.minor} detected")
        print("AsyncFlow requires Python 3.7 or higher")
        print("Please upgrade your Python installation")
        return False
    return True


async def demo_task(name: str, delay: float):
    """Simple async task for demonstration"""
    print(f"üìÑ Starting task: {name}")
    await asyncio.sleep(delay)
    print(f"‚úÖ Completed task: {name}")


async def main():
    """Main demo function"""
    print("üöÄ AsyncFlow Python Demo")
    print("=========================")
    print(f"Python version: {sys.version.split()[0]}")
    print(f"Platform: {platform.system()} {platform.release()}")
    print(f"Architecture: {platform.machine()}")
    print()

    # Demo 1: Sequential Processing
    print("üìã Demo 1: Sequential Task Processing")
    print("--------------------------------------")
    
    kernel = AsyncKernel()
    sequence = FlowFactory.new_sequence("DocumentProcessing")
    
    # Create tasks
    upload_task = FlowFactory.new_async_coroutine(
        demo_task("Upload Document", 1.5),
        "UploadTask"
    )
    
    scan_task = FlowFactory.new_async_coroutine(
        demo_task("Scan Document", 1.2), 
        "ScanTask"
    )
    
    process_task = FlowFactory.new_async_coroutine(
        demo_task("Process Document", 1.8),
        "ProcessTask"
    )
    
    # Add to sequence
    sequence.add_child(upload_task)
    sequence.add_child(scan_task)
    sequence.add_child(process_task)
    
    kernel.root.add_child(sequence)
    await kernel.run_until_complete()
    
    print()
    await asyncio.sleep(0.8)

    # Demo 2: Parallel Processing
    print("üîÑ Demo 2: Parallel File Processing")
    print("------------------------------------")
    
    kernel2 = AsyncKernel()
    barrier = FlowFactory.new_barrier("ParallelTasks")
    
    # Create parallel tasks
    task1 = FlowFactory.new_async_coroutine(
        demo_task("Download file1.pdf (2.1MB)", 2.1),
        "Download1"
    )
    
    task2 = FlowFactory.new_async_coroutine(
        demo_task("Download file2.docx (1.8MB)", 1.8),
        "Download2"
    )
    
    task3 = FlowFactory.new_async_coroutine(
        demo_task("Download file3.xlsx (2.4MB)", 2.4),
        "Download3"
    )
    
    # Add to barrier
    barrier.add_child(task1)
    barrier.add_child(task2)
    barrier.add_child(task3)
    
    # Compression after all downloads
    compress_task = FlowFactory.new_async_coroutine(
        demo_task("Compress all files", 1.2),
        "CompressTask"
    )
    
    # Create sequence: barrier then compress
    download_sequence = FlowFactory.new_sequence("DownloadAndCompress")
    download_sequence.add_child(barrier)
    download_sequence.add_child(compress_task)
    
    kernel2.root.add_child(download_sequence)
    await kernel2.run_until_complete()
    
    print()
    await asyncio.sleep(0.8)

    # Demo 3: Timer-based Processing
    print("‚è∞ Demo 3: Timer-based Progress System")
    print("--------------------------------------")
    
    kernel3 = AsyncKernel()
    counter = [0]  # Use list for mutable reference
    progress_timer = None
    
    def progress_callback():
        counter[0] += 1
        percentage = min(counter[0] * 20, 100)
        bar = "‚ñà" * (percentage // 10)
        space = "‚ñë" * (10 - percentage // 10)
        print(f"üìä Progress: [{bar}{space}] {percentage}%")
        
        # Stop timer when we reach 100%
        if percentage >= 100 and progress_timer:
            progress_timer.complete()
    
    # Create progress timer
    progress_timer = FlowFactory.new_periodic_timer(0.8, "ProgressTimer")
    progress_timer.set_elapsed_callback(progress_callback)
    
    # Create completion trigger
    completion_trigger = FlowFactory.new_trigger(
        lambda: counter[0] >= 5,
        "CompletionTrigger"
    )
    
    def completion_callback():
        print("üéâ Processing complete!")
        # Also stop the timer when completion is triggered
        if progress_timer:
            progress_timer.complete()
    
    completion_trigger.set_triggered_callback(completion_callback)
    
    # Background work
    background_work = FlowFactory.new_async_coroutine(
        demo_task("Background processing", 4.5),
        "BackgroundWork"
    )
    
    kernel3.root.add_child(progress_timer)
    kernel3.root.add_child(completion_trigger)
    kernel3.root.add_child(background_work)
    
    await kernel3.run_until_complete()
    
    print()
    await asyncio.sleep(0.8)

    # Demo 4: Future Communication
    print("üì° Demo 4: Future-based Communication")
    print("--------------------------------------")
    
    kernel4 = AsyncKernel()
    
    # Create futures
    config_future = FlowFactory.new_future("ConfigFuture")
    auth_future = FlowFactory.new_future("AuthFuture")
    
    # Configuration loader
    async def load_config():
        print("‚öôÔ∏è  Loading configuration...")
        await asyncio.sleep(1.4)
        await config_future.set_value("production-config-v2.1")
        print("‚úÖ Configuration loaded")
    
    config_loader = FlowFactory.new_async_coroutine(load_config(), "ConfigLoader")
    
    # Authentication service  
    async def authenticate():
        print("üîê Authenticating...")
        await asyncio.sleep(1.8)
        await auth_future.set_value(12345678)
        print("‚úÖ Authentication successful")
    
    auth_service = FlowFactory.new_async_coroutine(authenticate(), "AuthService")
    
    # Main service that waits for both
    async def main_service():
        print("‚è≥ Main service waiting for dependencies...")
        
        config = await config_future.wait()
        print(f"üìã Using config: {config}")
        
        token = await auth_future.wait()
        print(f"üé´ Using auth token: {token}")
        
        print("üöÄ Starting main service...")
        await asyncio.sleep(1.0)
        print("‚úÖ Main service running!")
    
    main_task = FlowFactory.new_async_coroutine(main_service(), "MainService")
    
    # Run all in barrier
    startup_barrier = FlowFactory.new_barrier("StartupServices")
    startup_barrier.add_child(config_loader)
    startup_barrier.add_child(auth_service)
    startup_barrier.add_child(main_task)
    
    kernel4.root.add_child(startup_barrier)
    await kernel4.run_until_complete()
    
    print()
    print("üéä All demos completed successfully!")
    print("====================================")
    print("AsyncFlow Python demonstrated:")
    print("  ‚úÖ Sequential task execution")
    print("  ‚úÖ Parallel processing with barriers")
    print("  ‚úÖ Timer-based progress tracking")
    print("  ‚úÖ Future-based communication")
    print("  ‚úÖ Zero threads - pure asyncio coordination!")
    print()
    print("Cross-platform usage:")
    print("  ‚Ä¢ Windows:    python pyr")
    print("  ‚Ä¢ Linux:      python3 pyr  (or ./pyr)")
    print("  ‚Ä¢ macOS:      python3 pyr  (or ./pyr)")
    print("  ‚Ä¢ No dependencies beyond Python 3.7+ stdlib!")


def run_demo():
    """Cross-platform demo runner"""
    if not check_python_version():
        return 1
    
    try:
        # Python 3.7+
        if hasattr(asyncio, 'run'):
            asyncio.run(main())
        else:
            # Python 3.6 fallback (though we require 3.7+)
            loop = asyncio.get_event_loop()
            try:
                loop.run_until_complete(main())
            finally:
                loop.close()
        return 0
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Demo interrupted by user")
        return 130
        
    except Exception as e:
        print(f"\n‚ùå Demo failed: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(run_demo())